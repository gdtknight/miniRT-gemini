<!--
SYNC 영향 보고서
==================
버전 변경: 4.0.0 → 5.0.0
업데이트: 2025-12-27

버전 5.0.0에 대한 근거:
- 메이저 버전 업데이트: 비협상 원칙인 프로젝트 구조 표준이 변경되었습니다. Wiki 문서의 소스 디렉토리가 `docs/wiki/`에서 프로젝트 루트의 `wiki/`로 이동했습니다. 이는 파일 경로에 의존하는 모든 자동화 또는 도구에 대한 파괴적인 변경입니다.

수정된 원칙:
- 원칙 I (프로젝트 구조 표준): Wiki 문서가 루트 `wiki/` 디렉토리에 위치하도록 예외를 추가했습니다.
- 원칙 III (문서 및 Wiki 동기화): Wiki의 단일 진실 공급원을 루트 `wiki/` 디렉토리로 변경했습니다.

업데이트가 필요한 템플릿:
✅ `docs/` 경로를 하드코딩한 템플릿을 찾지 못했습니다.

후속 조치:
- Wiki 문서를 기존 위치에서 새로운 루트 `wiki/` 디렉토리로 수동으로 이동해야 합니다.
-->

# miniRT 프로젝트 헌법

## 핵심 원칙

### I. 프로젝트 구조 표준 (협상 불가)

모든 프로젝트 파일은 CI 자동화, 사용자용 도구, 문서 간의 명확성을 유지하기 위해 엄격한 조직 규칙을 따라야 합니다.

**스크립트 조직**:
- CI 관련 스크립트는 `.github/scripts/`에 위치해야 합니다.
- 사용자용 유틸리티 스크립트는 접근성을 위해 프로젝트 루트에 유지되어야 합니다.

**문서 계층 구조**:
- 기술 명세(`specs/`), 아카이브(`docs/archive`) 등 대부분의 문서는 관련 디렉토리에 중앙 집중화되어야 합니다.
- 예외: GitHub Wiki와 동기화되는 Wiki 문서는 프로젝트 루트의 `wiki/` 디렉토리에 위치해야 합니다.
- 루트의 `CONTRIBUTING.md` 파일은 이 헌법을 참조하여 기여 프로세스를 정의해야 합니다.

**파일 수명 주기 관리**:
- 더 이상 사용되지 않는 파일은 흩어두지 말고 보관해야 합니다.
- 로그 및 빌드 아티팩트는 `.gitignore`에 정의되어야 합니다.

**근거**: 명확하고 일관된 프로젝트 구조는 혼란을 방지하고, 유지보수성을 향상시키며, 기여자들이 리소스를 신속하게 찾고 프로젝트 규칙을 이해할 수 있도록 보장합니다.

### II. 코드 품질 자동화 (협상 불가)

모든 코드 변경은 병합되기 전에 자동화된 품질 게이트를 통과해야 합니다.

**필수 품질 게이트**:
- **린팅**: 코드는 정적 린터(`42 school` 문맥에서는 `norminette`, 일반 프로젝트에서는 표준 린터)를 오류 없이 통과해야 합니다.
- **포매팅**: 코드는 자동 포매터(예: `clang-format`)에 의해 강제되는 정의된 스타일을 준수해야 합니다. 구성 파일이 리포지토리 루트에 있어야 합니다.
- **빌드**: 프로젝트는 지원되는 모든 플랫폼에서 오류 없이 빌드되어야 합니다.
- **메모리 안전성**: C/C++의 경우, 자동화된 검사(예: `valgrind`)에서 메모리 누수가 감지되지 않아야 합니다.

**CI 강제 적용**:
- 품질 게이트의 모든 실패는 CI 파이프라인을 실패시키고 PR 병합을 차단해야 합니다.
- CI 로그는 명확하고 실행 가능한 오류 메시지를 제공해야 합니다.

**근거**: 품질 관리를 자동화하면 일관성을 보장하고, 회귀를 방지하며, 프로젝트 안정성을 유지하여 개발자가 기능에 집중할 수 있도록 합니다.

### III. 문서 및 Wiki 동기화 (협상 불가)

GitHub Wiki는 사용자가 항상 최신 정보에 접근할 수 있도록 프로젝트 루트의 `wiki/` 디렉토리와 자동으로 동기화되어야 합니다.

**자동화 요구사항**:
- 버전 태그 생성은 자동 GitHub Wiki 업데이트를 트리거해야 합니다.
- 루트의 `wiki/` 디렉토리는 Wiki 문서의 단일 진실 공급원입니다.

**릴리스 동기화**:
- Wiki는 항상 최신 릴리스 태그에 해당하는 문서를 반영해야 합니다.
- 릴리스 노트는 릴리스 워크플로우의 일부로 생성 및 게시되어야 합니다.

**근거**: 자동 동기화는 문서의 불일치를 제거하고, 유지보수 부담을 줄이며, 공개 문서를 항상 정확하고 특정 소프트웨어 버전에 연결되도록 보장합니다.

### IV. 워크플로우 시스템 (협상 불가)

개발은 이 헌법에 정의된 구조화된 브랜칭 전략과 워크플로우를 따라야 합니다.

**풀 리퀘스트(PR) 워크플로우**:
- 모든 변경 사항은 PR을 통해 도입되어야 합니다. `main` 브랜치에 직접 푸시하는 것은 금지됩니다.
- PR은 병합을 고려하기 전에 모든 자동화된 검사(CI, 품질, 보안)를 통과해야 합니다.
- PR은 최소 한 명의 다른 기여자의 검토와 승인을 받아야 합니다.
- PR 제목과 설명은 변경 사항의 "무엇"과 "왜"를 명확하게 설명해야 합니다.

**릴리스 워크플로우**:
- 릴리스는 `main` 브랜치에서 생성되어야 합니다.
- 버전 태그는 시맨틱 버저닝(vX.Y.Z)을 따라야 합니다.
- 릴리스 프로세스는 Wiki 자동 업데이트, 릴리스 노트 생성, 빌드 아티팩트 게시를 트리거해야 합니다.

**근거**: 구조화된 워크플로우는 모든 변경 사항이 동료 검토를 받고, 자동으로 테스트되며, 적절하게 문서화되도록 보장하여 더 높은 품질과 더 안정적인 릴리스를 이끌어냅니다.

### V. 도구 및 환경 표준 (협상 불가)

개발 환경 및 도구는 여러 플랫폼을 지원하고 자동화된 종속성 관리를 제공해야 합니다.

**플랫폼 지원**:
- 프로젝트는 Linux 및 macOS를 지원해야 합니다. 빌드 시스템은 플랫폼 차이를 자동으로 처리해야 합니다.

**의존성 관리**:
- 모든 외부 의존성은 버전 및 라이선스와 함께 명시적으로 문서화되어야 합니다.
- 의존성을 추가하거나 업데이트하려면 PR이 필요하며 라이선스 호환성 및 보안 취약점에 대해 평가받아야 합니다.
- 빌드 시스템(예: `Makefile`)은 MiniLibX와 같은 필수 의존성의 가져오기 및 빌드를 자동화해야 합니다.

**빌드 및 테스트 인프라**:
- 테스트 아티팩트(씬, 데이터)는 `tests/` 디렉토리에 정리되어야 합니다.
- 빌드 및 로그 아티팩트는 `.gitignore`에 의해 제외된 디렉토리(`build/`, `logs/`)에 저장되어야 합니다.

**근거**: 표준화된 도구와 자동화된 의존성 관리는 새로운 기여자의 설정 마찰을 줄이고 모든 환경에서 일관되고 재현 가능한 빌드 프로세스를 보장합니다.

### VI. 이중 언어 명세 관리 (협상 불가)

모든 기능 명세는 모든 기여자 및 이해 관계자의 명확성을 보장하기 위해 영어와 한국어로 모두 유지되어야 합니다.

**동기화 요구사항**:
- 영어 명세(`specs/`)와 한국어 번역본(`specs/kr/`)은 불일치를 방지하기 위해 동일한 커밋/PR에서 업데이트되어야 합니다.
- 디렉토리 구조와 파일 이름은 미러링되어야 합니다.
- CI 검사는 한 언어의 변경 사항에 다른 언어의 해당 업데이트가 있는지 확인해야 합니다.

**근거**: 이중 언어 문서는 다양한 팀의 접근성과 명확성을 보장하며, 지역 42 School 커뮤니티와 더 넓은 국제 오픈 소스 기여자 모두를 지원합니다.

### VII. 42 School 함수 제약 조건 (선택 사항)

42 School의 커리큘럼과의 호환성을 위해, 이 프로젝트는 특정 제약 조건을 준수하는 "엄격한" 모드로 빌드될 수 있습니다. 이 섹션은 42 생태계 외부의 프로젝트에는 선택 사항입니다.

**허용된 함수 (엄격 모드)**:
- 표준 C 라이브러리 함수(`open`, `read`, `write`, `malloc`, `free`, `exit` 등).
- 수학 라이브러리(`math.h`).
- 제공된 `MiniLibX` 함수.
- 학생이 구현한 `libft` 및 `get_next_line`.

**금지된 함수 및 기술 (엄격 모드)**:
- `pthreads`, `fork` 또는 다른 형태의 멀티스레딩/멀티프로세싱 없음.
- 최적화를 위한 외부 라이브러리 없음(예: OpenMP, SIMD 내장 함수).

**근거**: 이러한 제약 조건은 42 School 시스템 내에서 공정한 평가를 보장하기 위한 교육적 목적입니다. 비활성화되면 프로젝트는 더 발전된 실제 기술을 활용할 수 있습니다. 빌드 플래그(예: `make STRICT=1`)가 이 모드를 제어해야 합니다.

### VIII. 보안 표준 (협상 불가)

프로젝트는 개발 수명 주기에 보안 모범 사례를 통합해야 합니다.

**자동화된 보안 게이트**:
- **SAST (정적 애플리케이션 보안 테스팅)**: CI 파이프라인은 모든 PR에 대해 소스 코드의 잠재적 취약점을 스캔하는 SAST 도구를 포함해야 합니다.
- **의존성 스캐닝**: CI 파이프라인은 알려진 취약점에 대해 모든 외부 의존성을 스캔해야 합니다(예: `trivy` 또는 GitHub의 Dependabot 사용).
- 높음 또는 치명적 심각도의 취약점은 빌드를 실패시키고 병합을 차단해야 합니다.

**안전한 코딩 관행**:
- 민감한 정보(키, 암호)는 하드코딩되어서는 안 됩니다. 환경 변수나 안전한 비밀 관리 시스템을 사용하십시오.
- 버퍼 오버플로와 같은 취약점을 방지하기 위해 입력 유효성 검사를 수행해야 합니다.

**근거**: 보안 취약점을 사전에 식별하고 완화하는 것은 신뢰할 수 있고 견고한 소프트웨어를 구축하는 데 중요합니다. 자동화는 보안이 나중의 생각이 아니라 프로세스의 일관된 부분이 되도록 보장합니다.

### IX. 브랜칭 전략 (협상 불가)

프로젝트는 깨끗하고 간단한 워크플로우를 보장하기 위해 **GitHub Flow** 브랜칭 모델을 따라야 합니다.

**브랜칭 모델**:
- `main`: 이 브랜치는 진실의 원천이며 항상 배포/릴리스 가능해야 합니다. 직접 푸시는 금지됩니다.
- **기능 브랜치**: 모든 새로운 작업(기능, 버그 수정)은 `main`에서 생성된 설명적인 기능 브랜치에서 수행되어야 합니다(예: `feat/add-new-object`, `fix/memory-leak-on-exit`).
- **병합**: 기능 브랜치는 모든 필수 검사와 검토를 통과한 후 풀 리퀘스트(PR)를 통해 `main`에 병합됩니다. 브랜치는 병합 후 삭제해야 합니다.

**근거**: GitHub Flow는 main 브랜치가 항상 좋은 상태를 유지하도록 보장함으로써 빈번한 통합 및 제공을 촉진하는 간단하고 효과적인 모델입니다.

### X. 커밋 메시지 규칙 (협상 불가)

모든 커밋 메시지는 명시적이고 쉽게 읽을 수 있는 프로젝트 히스토리를 생성하기 위해 **Conventional Commits** 사양을 따라야 합니다.

**형식**:
`<type>(<scope>): <subject>`
- **type**: `feat`(새 기능), `fix`(버그 수정), `docs`, `style`, `refactor`, `test`, `chore` 등.
- **scope**(선택 사항): 영향을 받는 코드베이스 부분(예: `parser`, `rendering`).
- **subject**: 변경 사항에 대한 간결한 설명.

**자동화**:
- CI 검사는 PR 제목이나 커밋 메시지가 이 형식을 준수하는지 확인해야 합니다. 이는 변경 로그의 자동 생성 및 버전 관리를 단순화합니다.

**근거**: 표준화된 커밋 히스토리는 기계가 읽을 수 있고 개발자 간의 의사소통을 개선하여 변경 사항을 이해하고 릴리스 노트를 자동화하기 쉽게 만듭니다.

### XI. 테스트 전략 및 커버리지 (협상 불가)

프로젝트는 정확성을 보장하고 회귀를 방지하기 위해 포괄적인 자동화 테스트 스위트를 유지해야 합니다.

**테스트 유형**:
- **단위 테스트**: 개별 함수 또는 구성 요소를 격리하여 테스트합니다. 빠르고 대부분의 테스트를 구성해야 합니다.
- **통합 테스트**: 여러 구성 요소 간의 상호 작용을 테스트합니다. (예: 씬 파일을 파싱하고 데이터 구조를 확인).
- **엔드 투 엔드(E2E) 테스트**: 입력에서 출력까지 전체 애플리케이션을 테스트합니다(예: `miniRT scenes/test.rt`를 실행하고 출력 이미지를 참조 이미지와 비교).

**테스트 커버리지**:
- 자동화된 테스트 커버리지 보고는 CI 파이프라인의 일부여야 합니다.
- 최소 코드 커버리지 목표(예: 80%)가 적용되어야 합니다. 커버리지를 임계값 아래로 낮추는 PR은 차단되어야 합니다.

**근거**: 다층적 테스트 전략은 코드 변경에 대한 신뢰를 제공하고, 버그를 조기에 발견하며, 리팩토링을 더 안전하게 만듭니다. 커버리지 목표를 강제하면 테스트 스위트가 코드베이스와 함께 성장하도록 보장합니다.

### XII. 폐기 정책 (협상 불가)

기능, 함수 또는 API는 사용자나 시스템의 다른 부분에 대한 파괴적인 변경을 피하기 위해 점진적으로 폐기되어야 합니다.

**폐기 프로세스**:
1.  **발표**: 코드에서 기능을 폐기 대상으로 표시하고(예: 주석 및 가능한 경우 컴파일러 경고 사용) 릴리스 노트에 발표합니다. 발표에는 폐기 이유와 대안이 명시되어야 합니다.
2.  **대기 기간**: 폐기된 기능은 사용자가 마이그레이션할 시간을 주기 위해 최소 한 번의 메이저 릴리스 주기 동안 계속 작동해야 합니다.
3.  **제거**: 대기 기간이 지나면 새 메이저 버전에서 폐기된 코드를 제거할 수 있습니다.

**근거**: 명확한 폐기 정책은 안정성과 예측 가능성을 제공하여 프로젝트 소비자가 시기적절하고 관리된 방식으로 변경 사항에 적응할 수 있도록 합니다.

## 거버넌스

이 헌법은 miniRT 프로젝트의 비협상 원칙을 정의합니다. 모든 개발 활동은 이를 준수해야 합니다.

**개정 절차**:
- 이 헌법의 변경은 PR이 필요하며, 동기화 영향 보고서에 문서화된 근거를 포함해야 하며, 프로젝트 유지 관리자의 승인을 받아야 합니다.
- 버전 관리: MAJOR(호환되지 않는 변경), MINOR(새로운 원칙), PATCH(명확화).

**준수 강제**:
- CI/CD 자동화는 모든 비협상 원칙을 강제해야 합니다.
- 코드 검토는 준수 여부를 확인해야 합니다. 편차는 거부되어야 합니다.

**버전**: 5.0.0 | **비준일**: 2025-12-27 | **최종 수정일**: 2025-12-27
